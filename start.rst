R2D2を使い始めるには
================================

ディレクトリ構造の準備
--------------------------------

R2D2は現在公開していないので、R2D2のzipファイルを堀田から受け取ったと仮定する。コードをしっかり読めば従う必要はないが、基本的には以下のようなディレクトリ構造で計算することを想定している。

.. code::

    project_name/
               ├─ run/
               │    ├─ d001/
               │    ├─ d002/
               │    ├─ d003/
               │    ├─ ...
               │
               ├─ py/
               └─ idl/


pyには `R2D2_py <https://github.com/hottahd/R2D2_py>`_ をクローンしてきたもの、idlには `R2D2_idl <https://github.com/hottahd/R2D2_idl>`_ をクローンしてきたものを配置する。ここは名前が変わっても問題ない。python(py)とidlのどちらかを使えば解析は可能である(両方ダウンロードする必要はない)。

堀田から受け取ったR2D2.zipファイルをそれぞれrunディレクトリのd001などと名前を変えて配置することで色々な計算ケースを実行するのが良いだろう。

R2D2ディレクトリの中は以下のようなディレクトリ構造になっている。

.. code::

   R2D2/
      ├─ F90_deps.py
      ├─ Makefile
      ├─ README.md
      ├─ gen_time.py
      ├─ data/
      │     ├─ param/
      │     │      ├─ nd.dac
      │     │      ├─ back.dac
      │     │      ├─ params.dac    
      │     │      └─ xyz.dac
      │     │
      │     ├─ qq/
      │     │   ├─ qq.dac.e
      │     │   ├─ qq.dac.o
      │     │   ├─ qq.dac.00000000
      │     │   ├─ qq.dac.00000001
      │     │   ├─ ...        
      │     │
      │     ├─ tau/
      │     │   ├─ qq.dac.00000000
      │     │   ├─ qq.dac.00000001
      │     │   ├─ ...        
      │     │
      │     ├─ remap/
      │     │      ├─ remap_info.dac
      │     │      ├─ qq/      
      │     │      │   ├─ qq.dac.00000000
      │     │      │   ├─ qq.dac.00000001
      │     │      │   ├─ ...              
      │     │      │
      │     │      └─ vl/
      │     │          ├─ c.dac
      │     │          ├─ vla.dac.00000000
      │     │          ├─ vla.dac.00000001
      │     │          ├─ vla.dac.00000002
      │     │          ├─ ...              
      │     │                     
      │     └─ time/
      │           ├─ mhd/
      │           │    ├─ t.dac.00000000
      │           │    ├─ t.dac.00000001
      │           │    ├─ ...
      │           │      
      │           └─ tau/
      │                ├─ t.dac.00000000
      │                ├─ t.dac.00000001
      │                ├─ ...
      │      
      ├─ input_data/
      ├─ make/
      ├─ retired_src/
      ├─ sh/
      └─ src/
           ├─ all/
           └─ include/

それぞれのファイル、ディレクトリの簡単な説明は以下である。

* F90_deps.py
    make/Makefile生成のためのpythonスクリプト。fortranコードの依存性を調べて、make/R2D2.depsに出力する。新しいプログラムを作成したときは

    .. code-block:: shell

        python F90_deps.py

    としてmake/R2D2.depsを更新する。
* Makefile
    makeをするときにmakeディクレクトリに移動する為のファイル。編集する必要はない。編集すべきMakefileはmake/Makefileに配置してある。
* README.md
    GitHubに表示する為の説明ファイル。情報が古くなっている可能性があるので、README.mdを見るよりは、このウェブページの情報を参照されたい。
* gen_time.py
    他のモデルから計算結果をもらったときにdataディレクトリや時間のファイルを生成する為のpythonスクリプト
* copy_caseid.py
    続きの計算を行うためのスクリプト
* data/
    fortranプログラムを実行した後に、データが保存されるディレクトリ。fortranプログラムを実行すると自動的に生成される。

    * data/param/
        基本的な計算設定パラメタを出力する為のディレクトリ
    * data/qq/
        チェックポイントのための３次元データを出力するためのディレクトリ
    * data/remap/
        解析のためのリマッピングをしたあとのデータを格納するディレクトリ

        * data/remap/qq/
            計算データをリマッピングして扱いやすくした三次元データ。単精度で出力。解析には主にこのデータを使う。
        * data/remap/vl/
            計算実行中の解析データ格納
    * data/time/
        出力した時間を記録したファイルを格納するディレクトリ。3次元データの出力の時間を記録する ``mhd`` と光学的厚さ一定の場所の出力の時間を記録する ``tau`` のディレクトリがある。
        
        * data/time/mhd/
            MHD量のアウトプットの時間データ
        * data/time/tau/
            光学的厚さ一定の面アウトプットの時間データ

コンパイル
--------------------------------
コンパイルは基本的にR2D2のディクレトリで

.. code:: shell

    make

とするのみである。使う計算機によって設定が違うので ``make/Makfile`` を編集する必要がある。
このファイルの1行目に

.. code:: Makefile

    SERVER=OFP

などと書いてある部分がある。計算機に応じてこの部分を書き換える。
それぞれ以下のような対応になっている。すでに使用できない計算機については説明しない。

* ``XC``: CfCA XC50
* ``OFP``: Oakforest-PACS
* ``FX``: 名大FX100

以下、堀田の個人環境なので、使用は推奨されない。どうしても個人の環境で使いたい時は堀田まで相談されたい。

* ``LOCAL``: UbuntuのGCC
* ``LOXAL_ifort``: Ubuntuのifort
*  ``MAC``: MacのGCC

基本的なパラメータ
--------------------------------
主に変更するパラメタは、**領域サイズ** と **格子点数** であろう。

これらは、``src/all/geometry_def.F90`` を編集することで変更できる。

まずは領域サイズ

.. code:: fortran

    real(KIND(0.d0)), parameter :: xmin = rsun - 23.876d8
    real(KIND(0.d0)), parameter :: xmax = rsun + 0.7d8
    real(KIND(0.d0)), parameter :: ymin = 0.d0
    real(KIND(0.d0)), parameter :: ymax = 6.144d8*16.d0
    real(KIND(0.d0)), parameter :: zmin = 0.d0
    real(KIND(0.d0)), parameter :: zmax = 6.144d8*16.d0

と書いてある箇所で領域サイズを決定している。*min, *maxはそれぞれ、*方向の領域の最小値、最大値である。x方向については、太陽中心からの距離で定義してあるので、 ``rsun`` を使うのが推奨される。

次に格子点数

.. code:: fortran

    integer, parameter, private :: nx0 = 128, ny0 = 64, nz0 = 64

.. code:: fortran

    integer, parameter :: ix0 = 4
    integer, parameter :: jx0 = 16
    integer, parameter :: kx0 = 16

などと書いてある箇所がある。``nx0`` , ``ny0`` , ``nz0`` はそれぞれ一つのMPIプロセスでのx, y, z方向の格子点の数を定義している。
一方、 ``ix0`` , ``jx0`` , ``kx0`` はそれぞれx, y, z方向のMPIプロセスの数を定義している。全MPIプロセス数は ``ix0*jx0*kx0`` となり、各方向の全体の格子点数はそれぞれ ``nx*ix0`` , ``ny*jx0`` , ``nz*kx0`` となる。

初期条件
--------------------------------
初期条件は、 ``src/all/model.F90`` で設定している。基本的な光球計算などは、鉛直速度にランダムな値を入れて計算を始めている。


追加条件
--------------------------------
ある程度計算を行った後に、続きの計算として少し設定を変えたい場合の手続きを示す。
例えば、磁場なしの熱対流計算を行った後に、磁場を加える場合などに有効である。

:code:`run/d001` での計算を:code:`run/d002` に移す場合について説明する。
:code:`run/d001` の下に :code:`copy_caseid.py` というスクリプトがあるのでそれを実行する(なければ堀田からもらう)

.. code::

    python copy_caseid.py

実行すると

.. code::

    Q1. Input destination caseid for copy, like d001

と質問されるので、データを移す先のcaseidを :code:`d002` などと入力する。

次に

.. code::

    Q2. Input time step for copy, like 10 or end

と質問されるので、移動したいデータの時間ステップを :code:`10` などと入力する。
チェックポイントのデータはデフォルトでは、10回に一回しか出力していないので注意すること。

また、現在行った計算の最後の時間ステップのデータを移動したい時は :code:`10` などの代わりに
:code:`end` と入力する。
するとプログラム・データのコピーが始まる。すでに移動先(今回場合は :code:`d002` に :code:`data` ディレクトリがある場合は、コピーが始まらないので、削除してからコピーすること)。

また、コピーが終わると移動先の :code:`data/cont_log.txt` に元データの情報が記載してある。

データをコピーした後に、磁場などを付け加えたい時は :code:`src/all/model_add.F90` を編集する.

.. code:: fortran

     do k = 1,nzg
     do j = 1,nyg
     do i = 1,nxg
        qq(5,i,j,k) = qq(5,i,j,k) + 200.d0
        qq(6,i,j,k) = qq(6,i,j,k)
        qq(7,i,j,k) = qq(7,i,j,k)
     enddo
     enddo
     enddo

などと書いてある。この例では鉛直磁場に200 Gが足されている。次に :code:`src/all/io.F90` を編集する。中ほどに

.. code:: fortran

    ! add something
    time00 = 0.d0
    if(ns == 0 .and. nd == 0) then
    !if(ns == 0) then
       !call model_sunspot
       !call model_fe_pff
       !call model_add
    endif

と書かれている部分があるので、 :code:`call model_add` の部分のコメントアウトを外す。 :code:`ns` は現在の計算のステップ数(続きの計算では引き継がれない)、 :code:`nd` は計算全体のデータアウトプット回数(続きの計算で引き継がれる)。この二つの変数が0の時は、計算の一番はじめもしくは、データを引き継いだ時のみなので、その時のみ追加条件が発動する。

スーパーコンピュータでのシェルスクリプト
--------------------------------
いくつかのスーパーコンピュータでジョブを投入するためのシェルスクリプトも ``sh`` ディレクトリに用意している。
使用コア数などを変えたい時は、それぞれのスーパーコンピュータの使用説明書などを参照すること。
今後使うことのできるものだけをあげる。

* ``fx.sh`` : 名大FX100
* ``ofp.sh`` : Oakforest-PACS
* ``xc.sh`` : CfCA XC50

初期条件データを受け取った場合
--------------------------------

熱対流が統計的定常に達するまでは非常に時間がかかるために、この計算が非常に困難になる。そのため、堀田がデータを提供することがある。堀田は :code:`data` ディレクトリを丸ごと提供する。

このディレクトリに :code:`cont_log.txt` というファイルがあるので、そこに示されている計算設定の情報を見て同じようになるように計算を設定する。

このディレクトリを書く実行のディレクトリの配下におき、実行すると続きの計算が始まる。

最終更新日：|today|